<script>
    import { createLogger } from '../utils/logger';
    import type { HeadingEntry, ILogger } from '../types';
    import { headingStore } from '../stores/heading';
    import { HEADING_LINKS } from '../config/components';

    // Create a logger instance with the 'HeadingLinks' prefix.
    const logger: ILogger = createLogger({ prefix: 'HeadingLinks' });

    // Define a type for valid headings.
    interface ValidHeading extends HeadingEntry {
        id: string; // Heading ID
        text: string; // Heading text
        depth: number; // Heading depth
    }

    /** Manager for heading links in MDX content. Handles heading ID generation, anchor creation, and table of contents management. */
    class HeadingLinksManager {
        /** Selector for finding headings in MDX content */
        private static readonly HEADING_SELECTOR = HEADING_LINKS.SELECTOR;

        /** Regex for converting text to URL-friendly format */
        private static readonly ID_REGEX = HEADING_LINKS.ID_REGEX;

        /** Regex for trimming hyphens from start and end */
        private static readonly TRIM_REGEX = HEADING_LINKS.TRIM_REGEX;

        /** Map to track used IDs and their counts for duplicate prevention */
        private usedIds: Map<string, number>;

        /** Constructor for the HeadingLinksManager class. Initializes the usedIds map. */
        constructor() {
            this.usedIds = new Map<string, number>();
        }

        /**
         * Smoothly scroll to the target element.
         *
         * @param targetId - ID of the target element to scroll to
         */
        private smoothScrollTo(targetId: string): void {
            const targetElement = document.getElementById(targetId);

            if (!targetElement) {
                logger.error(`Target heading not found: ${targetId}`);
                return;
            }

            window.scrollTo({
                top: targetElement.offsetTop,
                behavior: 'smooth'
            });
        }

        /**
         * Generate a heading ID.
         *
         * @param text - Text to generate an ID from
         * @returns Heading ID
         */
        private generateHeadingId(text: string | null): string | null {
            let o: string | null = null;

            if (text) {
                const baseId = text.toLowerCase().replace(HeadingLinksManager.ID_REGEX, '-').replace(HeadingLinksManager.TRIM_REGEX, '');

                if (this.usedIds.has(baseId)) {
                    const count = this.usedIds.get(baseId)! + 1;
                    this.usedIds.set(baseId, count);
                    o = `${baseId}-${count}`;
                } else {
                    this.usedIds.set(baseId, 1);
                    o = baseId;
                }
            }

            return o;
        }

        /**
         * Create an anchor element.
         *
         * @param id - ID to link to
         * @returns Anchor element
         */
        private createAnchorElement(id: string): HTMLAnchorElement {
            const anchor: HTMLAnchorElement = document.createElement('a');

            anchor.className = HEADING_LINKS.ANCHOR_CLASS;
            anchor.href = `#${id}`;
            anchor.innerHTML = '#';
            anchor.setAttribute('aria-hidden', 'true');

            return anchor;
        }

        /**
         * Handle an anchor click.
         *
         * @param e - Mouse event
         * @param id - ID to link to
         */
        private handleAnchorClick(e: MouseEvent, id: string): void {
            e.preventDefault();

            // Construct the URL with the heading ID.
            const url = `${window.location.origin}${window.location.pathname}#${id}`;

            // Scroll to the heading and update the URL.
            this.smoothScrollTo(id);
            window.history.pushState({}, '', url);

            // Copy the URL to the clipboard.
            navigator.clipboard.writeText(url).catch((error) => {
                logger.error('Failed to copy URL to clipboard', error);
            });
        }

        /** Add heading links to all headings. */
        public addHeadingLinks(): void {
            this.usedIds = new Map<string, number>();
            const headings: NodeListOf<HTMLHeadingElement> = document.querySelectorAll(HeadingLinksManager.HEADING_SELECTOR);

            headings.forEach((headingElement) => {
                const id = this.generateHeadingId(headingElement.textContent);

                if (id) {
                    const anchor = this.createAnchorElement(id);
                    anchor.addEventListener('click', (e) => this.handleAnchorClick(e, id));
                    headingElement.insertAdjacentElement('afterbegin', anchor);
                    headingElement.id = id;
                }
            });
        }

        /**
         * Collect headings from the page.
         *
         * @returns Array of headings.
         */
        public collectHeadings(): HeadingEntry[] {
            const headings: HeadingEntry[] = [];
            const headingElements: NodeListOf<HTMLHeadingElement> = document.querySelectorAll(HeadingLinksManager.HEADING_SELECTOR);

            this.usedIds = new Map<string, number>();

            headingElements.forEach((heading) => {
                const text = heading.textContent;
                const id = this.generateHeadingId(text);
                const depth = parseInt(heading.tagName.charAt(1));

                if (id && text) {
                    // Remove the # prefix, since that's the heading activation hyperlink.
                    headings.push({ id, text: text!.replace(/^#/, ''), depth });
                } else {
                    logger.error(`[heading-links] Heading link text not found: ${heading.textContent}`);
                }
            });

            return headings;
        }

        /** Refresh the heading links. */
        public refresh = (): void => {
            logger.info('Refreshing heading links');

            try {
                this.addHeadingLinks();
                const headings = this.collectHeadings();
                const validHeadings: ValidHeading[] = headings.filter((h): h is ValidHeading => Boolean(h.id && h.text));

                if (validHeadings.length === 0) {
                    logger.warn('No headings found in content');
                } else {
                    logger.info(`Found ${validHeadings.length} valid headings`);
                }

                headingStore.set(validHeadings);
            } catch (error) {
                logger.error('Failed to refresh heading links', error);
            }
        };
    }

    // Initialize heading links manager.
    try {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                const manager = new HeadingLinksManager();
                manager.refresh();

                document.addEventListener('astro:page-load', () => {
                    manager.refresh();
                });
            });
        } else {
            const manager = new HeadingLinksManager();
            manager.refresh();

            document.addEventListener('astro:page-load', () => {
                manager.refresh();
            });
        }
    } catch (error) {
        logger.error('[HeadingLinks] Failed to initialize heading links manager', error);
    }
</script>
