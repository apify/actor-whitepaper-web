<div class="pointer-events-none fixed right-0 top-0 h-full w-16 mix-blend-exclusion min-[1140px]:pr-4" id="toc-progress">
    <div id="toc-progress-bars" class="relative h-full"></div>
</div>

<nav class="toc-nav" id="toc-nav" aria-label="Table of Contents">
    <div class="bg-background-toc-toolbar dark:bg-background-toc-toolbar-dark sticky left-0 top-0 flex items-center justify-between p-6">
        <input type="text" id="toc-filter" placeholder="Filter..." aria-label="Filter TOC" class="bg-background-toc-filter dark:bg-background-toc-filter-dark w-full rounded-md px-2 py-1 text-toc-item shadow-sm" />
    </div>

    <ul id="toc-list" class="mb-4 text-toc-item" role="list"></ul>
</nav>

<script>
    import { createLogger } from '../utils/logger';
    import { debounce } from '../utils/debounce';
    import { safeExecute } from '../utils/safe-execute';
    import { TOC } from '../config/components';
    import { headingStore } from '../stores/heading';
    import type { TOCEntry, ProgressBarStyles, HeadingEntry } from '../types/toc';
    import { safeQuerySelector } from '../utils/dom';

    // Create a logger instance with the 'TOC' prefix.
    const logger = createLogger({ prefix: 'TOC' });

    // Add interfaces for better type safety.
    interface TOCState {
        isVisible: boolean; // Whether the TOC is visible
        isScrolling: boolean; // Whether the user is scrolling
        lastScrollPosition: number; // Last scroll position
    }

    // Interface for TOC elements.
    interface TOCElements {
        nav: HTMLElement | null; // Navigation element
        filterInput: HTMLElement | null; // Filter input element
        tocList: HTMLElement | null; // TOC list element
        progressBars: HTMLElement | null; // Progress bars element
    }

    /** Manager for Table of Contents functionality. */
    class TOCManager {
        /** ID of the currently active heading. */
        private activeId: string = '';

        /** State of the TOC manager. */
        private readonly state: TOCState = {
            isVisible: false,
            isScrolling: false,
            lastScrollPosition: 0
        };

        /** Elements of the TOC. */
        private readonly elements: TOCElements = {
            nav: document.getElementById('toc-nav'),
            filterInput: document.getElementById('toc-filter'),
            tocList: document.getElementById('toc-list'),
            progressBars: document.getElementById('toc-progress-bars')
        };

        /** Intersection observer for tracking heading visibility. */
        private readonly observer: IntersectionObserver;

        /** Interval ID for rendering progress bars. */
        private readonly intervalId: number;

        /** Debounced function to render progress bars. */
        private readonly debouncedRenderProgressBars: () => void;

        constructor() {
            // Initialize the observer with the appropriate root margin.
            this.observer = new IntersectionObserver((entries) => this.handleIntersection(entries), { rootMargin: TOC.OBSERVER_MARGIN });

            // Debounce the progress bar rendering.
            this.debouncedRenderProgressBars = debounce(() => this.renderProgressBars(), TOC.PROGRESS_BAR_DEBOUNCE);

            // Set up event listeners and interval for scroll checking.
            this.setupEventListeners();
            this.intervalId = window.setInterval(() => this.onScroll(), TOC.SCROLL_CHECK_INTERVAL);
        }

        /**
         * Handles intersection events from the observer.
         *
         * @param entries - Intersection observer entries
         */
        private handleIntersection(entries: IntersectionObserverEntry[]): void {
            // Update the active heading if the entry is intersecting.
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    // Update the active heading if the entry is intersecting.
                    this.updateActiveHeading(entry.target.id);
                }
            });
        }

        /** Sets up event listeners for the TOC. */
        private setupEventListeners(): void {
            // Subscribe to heading changes.
            headingStore.subscribe((value: readonly HeadingEntry[]) => {
                // Render the TOC if there are headings.
                if (value.length > 0) {
                    logger.info(`${value.length} headings found, rendering TOC`);
                    this.renderTOC();
                } else {
                    logger.warn('No headings found');
                }
            });

            // Handle filter input changes.
            this.elements.filterInput?.addEventListener('input', (event) => {
                const filter = (event.target as HTMLInputElement).value.toLowerCase();
                this.renderTOC(filter);
            });

            // Add event listeners for scroll and mouse move.
            window.addEventListener('scroll', () => this.onScroll(), { passive: true });
            window.addEventListener('mousemove', this.handleMouseMove, { passive: true });
        }

        /**
         * Updates the active heading and toggles the active class on the TOC items.
         *
         * @param id - ID of the active heading
         */
        private updateActiveHeading(id: string): void {
            this.activeId = id;

            const tocItems = document.querySelectorAll('.toc-item');

            // Toggle the active class on the TOC items.
            tocItems.forEach((item) => {
                const link = safeQuerySelector<HTMLAnchorElement>(`a[href="#${id}"]`, item);
                const isActive = link !== null;

                item.classList.toggle('is-active', isActive);

                if (isActive) {
                    // Scroll the active item into view if it's not already visible.
                    this.scrollActiveItemIntoView(item);
                }
            });

            // Render the progress bars and update the aria labels.
            this.renderProgressBars();
            this.updateAriaLabels();
        }

        /**
         * Scrolls the active item into view if it's not already visible.
         *
         * @param item - TOC item element
         */
        private scrollActiveItemIntoView(item: Element): void {
            if (!this.elements.nav || !this.elements.tocList) return; // return if the navigation element or the TOC list element is not found

            const tocRect = this.elements.tocList.getBoundingClientRect();
            const itemRect = item.getBoundingClientRect();
            const visibleTop = Math.max(tocRect.top, window.innerHeight * TOC.VIEWPORT_MARGINS.TOP + 100);
            const visibleBottom = Math.min(tocRect.bottom, window.innerHeight * TOC.VIEWPORT_MARGINS.BOTTOM);

            // Scroll the item into view if it's not already visible.
            if (itemRect.top < visibleTop || itemRect.bottom > visibleBottom) {
                item.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });
            }
        }

        /** Updates the aria labels on the TOC items. */
        private updateAriaLabels(): void {
            const links = document.querySelectorAll('.toc-item a');

            // Update the aria labels on the TOC items.
            links.forEach((link) => {
                link.setAttribute('aria-current', link.getAttribute('href') === `#${this.activeId}` ? 'true' : 'false');
            });
        }

        /**
         * Gets the styles for the progress bars.
         *
         * @param heading - TOC entry
         * @param index - Index of the heading
         * @returns Progress bar styles
         */
        private getProgressBarStyles(heading: TOCEntry, index: number): ProgressBarStyles {
            return {
                width: (5 - heading.depth) * TOC.PROGRESS_BAR_BASE_WIDTH,
                height: TOC.PROGRESS_BAR_HEIGHT,
                top: index * (TOC.PROGRESS_BAR_HEIGHT + TOC.PROGRESS_BAR_SPACING)
            };
        }

        /** Renders the progress bars. */
        private renderProgressBars(): void {
            safeExecute(
                () => {
                    if (!this.elements.progressBars) return; // return if the progress bars element is not found

                    const headings = headingStore.get();
                    const totalSpacing = (headings.length - 1) * TOC.PROGRESS_BAR_SPACING;
                    const totalBarsHeight = headings.length * TOC.PROGRESS_BAR_HEIGHT;
                    const containerHeight = totalBarsHeight + totalSpacing;

                    // Render the progress bars.
                    this.elements.progressBars.innerHTML = headings
                        .map((heading, index) => {
                            const styles = this.getProgressBarStyles(heading, index);
                            return `
                                <div
                                    data-heading-id="${heading.id}"
                                    class="progress-bar absolute right-0 ${heading.id === this.activeId ? 'bg-toc-progress-active' : 'bg-toc-progress'}"
                                    style="
                                        width: ${styles.width}px;
                                        height: ${styles.height}px;
                                        top: ${styles.top}px;
                                    "
                                ></div>
                            `;
                        })
                        .join('');

                    // Set the height, top, and transform of the progress bars container.
                    this.elements.progressBars.style.height = `${containerHeight}px`;
                    this.elements.progressBars.style.top = '50%';
                    this.elements.progressBars.style.transform = 'translateY(-50%)';

                    logger.info(`Rendered ${headings.length} progress bars`);
                },
                undefined,
                'Failed to render progress bars'
            );
        }

        /** Handles mouse move events. */
        private handleMouseMove = (event: MouseEvent): void => {
            if (!this.elements.nav) return; // return if the navigation element is not found

            const mouseX = event.clientX;
            const windowWidth = window.innerWidth;
            const threshold = windowWidth - TOC.MOUSE_THRESHOLD;
            const shouldShow = mouseX > threshold;

            // Toggle the visibility of the TOC based on the mouse position.
            if (shouldShow !== this.state.isVisible) {
                this.state.isVisible = shouldShow;
                this.elements.nav.style.pointerEvents = shouldShow ? 'auto' : 'none';
                this.elements.nav.style.opacity = shouldShow ? '1' : '0';
            }
        };

        /** ID of the request animation frame. */
        private rafId: number | null = null;

        /** Handles scroll events. */
        private onScroll = (): void => {
            if (this.rafId || this.state.isScrolling) return; // return if an animation frame is already in progress or if the user is scrolling

            this.state.isScrolling = true;
            this.rafId = requestAnimationFrame(() => {
                safeExecute(
                    () => {
                        // Get the headings and the scroll position.
                        const headings = headingStore.get();
                        const scrollPosition = window.scrollY + window.innerHeight * TOC.VIEWPORT_MARGINS.TOP;
                        const currentPosition = Math.abs(scrollPosition - this.state.lastScrollPosition);

                        // Update the last scroll position if the current position is greater than the threshold.
                        if (currentPosition > TOC.SCROLL_THRESHOLD) {
                            this.state.lastScrollPosition = scrollPosition;

                            // Find the active heading based on the scroll position.
                            for (let i = headings.length - 1; i >= 0; i--) {
                                const element = document.getElementById(headings[i].id);

                                if (element && element.offsetTop <= scrollPosition) {
                                    this.updateActiveHeading(headings[i].id);
                                    break;
                                }
                            }
                        }

                        // Render the progress bars and update the aria labels.
                        this.debouncedRenderProgressBars();
                        this.updateAriaLabels();

                        // Reset the scrolling state.
                        this.state.isScrolling = false;
                        this.rafId = null;
                    },
                    undefined,
                    'Failed to handle scroll event'
                );
            });
        };

        /**
         * Renders the TOC.
         *
         * @param filter - Filter string
         */
        private renderTOC(filter: string = ''): void {
            safeExecute(
                () => {
                    if (!this.elements.tocList) return; // return if the TOC list element is not found

                    // Get the headings and filter them based on the filter string.
                    const headings = headingStore.get().filter((heading) => heading.text.toLowerCase().includes(filter));

                    // Render the TOC items.
                    this.elements.tocList.innerHTML = headings
                        .map(
                            (heading) => `
                            <li class="toc-item ${heading.id === this.activeId ? 'is-active' : ''}" role="listitem">
                                <a class="toc-depth-${heading.depth - 1}" href="#${heading.id}" aria-current="${heading.id === this.activeId ? 'true' : 'false'}">
                                    ${heading.text}
                                </a>
                            </li>
                        `
                        )
                        .join('');

                    // Render the progress bars.
                    this.debouncedRenderProgressBars();
                },
                undefined,
                'Failed to render TOC'
            );
        }

        /** Cleans up the TOC manager. */
        public cleanup(): void {
            safeExecute(
                () => {
                    // Cancel the animation frame if it's in progress.
                    if (this.rafId) {
                        cancelAnimationFrame(this.rafId);
                        this.rafId = null;
                    }

                    // Clear the interval for scroll checking.
                    clearInterval(this.intervalId);

                    // Remove event listeners.
                    window.removeEventListener('scroll', this.onScroll);
                    window.removeEventListener('mousemove', this.handleMouseMove);

                    // Remove intersection observers.
                    document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((heading) => {
                        this.observer.unobserve(heading);
                    });

                    logger.info('TOC manager cleaned up successfully');
                },
                undefined,
                'Failed to cleanup TOC manager'
            );
        }

        /** Initializes the TOC manager. */
        public initialize(): void {
            safeExecute(
                () => {
                    // Remove previous observers
                    document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((heading) => {
                        this.observer.unobserve(heading);
                    });

                    // Add new observers.
                    headingStore.get().forEach((heading) => {
                        const element = document.getElementById(heading.id);
                        if (element) {
                            this.observer.observe(element);
                        }
                    });

                    // Render the TOC and find the first visible heading.
                    this.renderTOC();
                    this.findAndActivateFirstVisibleHeading();

                    logger.info('TOC manager initialized successfully');
                },
                undefined,
                'Failed to initialize TOC manager'
            );
        }

        /** Finds and activates the first visible heading. */
        private findAndActivateFirstVisibleHeading(): void {
            const entries = headingStore.get();

            if (entries.length === 0) return; // return if there are no headings

            // Find the first visible heading.
            const firstVisibleHeading = entries.find((heading) => {
                const element = document.getElementById(heading.id);

                if (!element) return false; // return if the heading element is not found

                const rect = element.getBoundingClientRect();

                return rect.top >= 0 && rect.top <= window.innerHeight * 0.2;
            });

            this.updateActiveHeading(firstVisibleHeading?.id || entries[0].id);
        }
    }

    // Initialize TOC manager.
    safeExecute(
        () => {
            const manager = new TOCManager();
            manager.initialize();

            // Handle Astro page transitions.
            document.addEventListener('astro:page-load', () => {
                manager.initialize();
            });

            // Cleanup on navigation.
            document.addEventListener('astro:before-preparation', () => {
                manager.cleanup();
            });
        },
        undefined,
        'Failed to setup TOC manager'
    );
</script>

<style is:global>
    .toc-nav {
        @apply bg-background-toc dark:bg-background-toc-dark pointer-events-none fixed right-0 top-[10%] h-[80%] w-80 overflow-y-auto rounded-l-xl opacity-0 shadow-xl min-[1140px]:right-4 min-[1140px]:rounded-xl;
    }

    .toc-item {
        @apply px-6;

        & a {
            @apply text-text-toc hover:text-primary-hover dark:text-text-toc-dark dark:hover:text-primary-dark-hover block text-balance px-1 py-1;

            &.toc-depth-1 {
                @apply pl-0;
            }

            &.toc-depth-2 {
                @apply pl-[16px];
            }

            &.toc-depth-3 {
                @apply pl-[32px];
            }

            &.toc-depth-4 {
                @apply pl-[48px];
            }
        }
    }

    .toc-item.is-active {
        @apply bg-background-toc-active dark:bg-background-toc-active-dark shadow-sm;

        & a {
            @apply text-text-toc-active dark:text-text-toc-active-dark;
        }
    }
</style>
