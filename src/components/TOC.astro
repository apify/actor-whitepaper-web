<div class="pointer-events-none fixed right-0 top-0 h-full w-16 min-[1140px]:pr-4" id="toc-progress">
    <div id="toc-progress-bars" class="relative h-full"></div>
</div>

<nav class="pointer-events-none fixed right-0 top-[10%] h-[80%] w-80 overflow-y-auto rounded-l-xl bg-toc-bg opacity-0 shadow-xl transition-opacity duration-200 min-[1140px]:right-4 min-[1140px]:rounded-xl dark:bg-toc-bg-dark" id="toc-nav" aria-label="Table of Contents">
    <div class="sticky left-0 top-0 flex items-center justify-between bg-toc-toolbar-bg p-6 dark:bg-toc-toolbar-bg-dark">
        <input type="text" id="toc-filter" placeholder="Filter..." aria-label="Filter TOC" class="w-full rounded-md bg-toc-filter-bg px-2 py-1 text-toc-item shadow-sm dark:bg-toc-filter-bg-dark" />
    </div>
    <ul id="toc-list" class="mb-4 text-toc-item"></ul>
</nav>

<script>
    import { createLogger } from '../utils/logger';
    import type { HeadingEntry, ILogger } from '../types';
    import { headingStore } from '../stores/heading';

    // Create a logger instance with the 'TOC' prefix.
    const logger: ILogger = createLogger({ prefix: 'TOC' });

    /** Manager for Table of Contents functionality. */
    class TOCManager {
        /** ID of the currently active heading */
        private activeId: string = '';

        /** Request animation frame ID */
        private rafId: number | null = null;

        /** Reference to the TOC navigation element */
        private readonly nav: HTMLElement | null;

        /** Reference to the filter input element */
        private readonly filterInput: HTMLElement | null;

        /** Reference to the TOC list element */
        private readonly tocList: HTMLElement | null;

        /** Interval ID for periodic checks */
        private readonly intervalId: number;

        /** Observer for tracking heading visibility */
        private readonly observer: IntersectionObserver;

        /** Constructor for the TOCManager class. Initializes DOM references and the observer. */
        constructor() {
            // Initialize DOM references.
            this.nav = document.getElementById('toc-nav');
            this.filterInput = document.getElementById('toc-filter');
            this.tocList = document.getElementById('toc-list');

            // Initialize intersection observer.
            this.observer = new IntersectionObserver(
                (entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            this.updateActiveHeading(entry.target.id);
                        }
                    });
                },
                { rootMargin: '0px 0px -80% 0px' }
            );

            // Set up event listeners.
            this.setupEventListeners();

            // Initialize periodic check.
            this.intervalId = window.setInterval(() => this.onScroll(), 1000);
        }

        /** Set up event listeners for TOC functionality. */
        private setupEventListeners(): void {
            // Subscribe to heading store changes.
            headingStore.subscribe((value: readonly HeadingEntry[]) => {
                if (value.length > 0) {
                    logger.info(`${value.length} headings found, rendering TOC`);
                    this.renderTOC();
                } else {
                    logger.warn('No headings found');
                }
            });

            // Filter input handler.
            this.filterInput?.addEventListener('input', (event) => {
                const filter = (event.target as HTMLInputElement).value.toLowerCase();
                this.renderTOC(filter);
            });

            // Scroll and keyboard handlers.
            window.addEventListener('scroll', () => this.onScroll(), { passive: true });
            window.addEventListener('keyup', this.handleKeyboardNavigation);

            // Mouse tracking.
            window.addEventListener('mousemove', this.handleMouseMove, { passive: true });
        }

        /**
         * Update the active heading in the TOC.
         *
         * @param id - ID of the heading to activate
         */
        private updateActiveHeading(id: string): void {
            this.activeId = id;

            document.querySelectorAll('.toc-item').forEach((item) => {
                const isActive = item.querySelector(`a[href="#${id}"]`) !== null;

                item.classList.toggle('is-active', isActive);

                if (isActive && this.nav && this.tocList) {
                    // Get TOC and item bounding rectangles.
                    const tocRect = this.tocList.getBoundingClientRect();
                    const itemRect = item.getBoundingClientRect();
                    const visibleTop = Math.max(tocRect.top, window.innerHeight * 0.1 + 100);
                    const visibleBottom = Math.min(tocRect.bottom, window.innerHeight * 0.9);
                    const isAbove = itemRect.top < visibleTop;
                    const isBelow = itemRect.bottom > visibleBottom;

                    // Scroll to the item if it's above or below the visible area.
                    if (isAbove || isBelow) {
                        item.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                    }
                }
            });

            this.updateProgressBars(id);
        }

        /**
         * Update progress bars to reflect current active heading.
         *
         * @param activeId - ID of the active heading
         */
        private updateProgressBars(activeId: string): void {
            document.querySelectorAll('.progress-bar').forEach((bar) => {
                const barId = bar.getAttribute('data-heading-id');

                bar.classList.toggle('bg-toc-progress-active', barId === activeId);
                bar.classList.toggle('bg-toc-progress', barId !== activeId);
            });
        }

        /**
         * Render the TOC with optional filtering.
         *
         * @param filter - Optional filter string to filter headings
         */
        private renderTOC(filter: string = ''): void {
            try {
                if (this.tocList) {
                    this.tocList.innerHTML = headingStore
                        .get()
                        .filter((heading) => heading.text.toLowerCase().includes(filter))
                        .map(
                            (heading) => `
                                <li class="toc-item ${heading.id === this.activeId ? 'is-active' : ''}">
                                    <a class="py-toc-y px-toc-item-x pl-toc-d${heading.depth - 1} block text-balance text-toc-text dark:text-toc-text-dark" href="#${heading.id}">
                                        ${heading.text}
                                    </a>
                                </li>`
                        )
                        .join('');
                }

                // Render progress bars.
                requestAnimationFrame(() => this.renderProgressBars());
            } catch (error) {
                logger.error('Failed to render TOC', error);
            }
        }

        /** Render progress bars for the TOC */
        private renderProgressBars(): void {
            try {
                const progressBarsContainer = document.getElementById('toc-progress-bars');

                if (!progressBarsContainer) return;

                // Get headings and calculate the container height.
                const headings = headingStore.get();
                const spacing = 4;
                const barHeight = 2;
                const totalSpacing = (headings.length - 1) * spacing;
                const totalBarsHeight = headings.length * barHeight;
                const containerHeight = totalBarsHeight + totalSpacing;

                // Render progress bars.
                progressBarsContainer.innerHTML = headings
                    .map(
                        (heading, index) => `
                        <div
                            data-heading-id="${heading.id}"
                            class="progress-bar absolute right-0 ${heading.id === this.activeId ? 'bg-toc-progress-active dark:bg-toc-progress-active-dark' : 'bg-toc-progress dark:bg-toc-progress-dark'}"
                            style="
                                width: ${(5 - heading.depth) * 8}px;
                                height: ${barHeight}px;
                                top: ${index * (barHeight + spacing)}px;
                            "
                        ></div>
                    `
                    )
                    .join('');

                // Set progress bar container styles.
                progressBarsContainer.style.height = `${containerHeight}px`;
                progressBarsContainer.style.top = '50%';
                progressBarsContainer.style.transform = 'translateY(-50%)';

                logger.info(`Rendered ${headings.length} progress bars`);
            } catch (error) {
                logger.error('Failed to render progress bars', error);
            }
        }

        /**
         * Handle keyboard navigation.
         *
         * @param event - Keyboard event
         */
        private handleKeyboardNavigation = (event: KeyboardEvent): void => {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                event.preventDefault();

                // Get headings and find the current index.
                const headings = headingStore.get();
                const currentIndex = headings.findIndex((h) => h.id === this.activeId);

                if (currentIndex === -1) return;

                // Calculate the new index based on the keyboard event.
                const newIndex = event.key === 'ArrowUp' ? Math.max(0, currentIndex - 1) : Math.min(headings.length - 1, currentIndex + 1);

                // Get the target ID and element.
                const targetId = headings[newIndex].id;
                const targetElement = document.getElementById(targetId);

                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                }
            }
        };

        /**
         * Handle mouse movement for TOC visibility.
         *
         * @param event - Mouse event
         */
        private handleMouseMove = (event: MouseEvent): void => {
            if (!this.nav) return;

            // Get mouse position and window width.
            const mouseX = event.clientX;
            const windowWidth = window.innerWidth;
            const threshold = windowWidth - 400;

            // Show TOC if mouse is over the threshold.
            if (mouseX > threshold) {
                this.nav.style.pointerEvents = 'auto';
                this.nav.style.opacity = '1';
            } else {
                this.nav.style.pointerEvents = 'none';
                this.nav.style.opacity = '0';
            }
        };

        /** Handle scroll events. */
        private onScroll(): void {
            if (this.rafId) return;

            this.rafId = requestAnimationFrame(() => {
                try {
                    // Get headings and calculate the scroll position.
                    const headings = headingStore.get();
                    const scrollPosition = window.scrollY + window.innerHeight * 0.2;

                    // Find the active heading based on the scroll position.
                    for (let i = headings.length - 1; i >= 0; i--) {
                        const element = document.getElementById(headings[i].id);

                        if (element && element.offsetTop <= scrollPosition) {
                            this.updateActiveHeading(headings[i].id);
                            break;
                        }
                    }

                    this.rafId = null;
                } catch (error) {
                    logger.error('Failed to handle scroll event', error);
                    this.rafId = null;
                }
            });
        }

        /** Clean up event listeners and intervals. */
        public cleanup(): void {
            if (this.rafId) {
                cancelAnimationFrame(this.rafId);
                this.rafId = null;
            }

            clearInterval(this.intervalId);

            window.removeEventListener('scroll', () => this.onScroll());
            window.removeEventListener('keyup', this.handleKeyboardNavigation);
            window.removeEventListener('mousemove', this.handleMouseMove);
        }

        /** Initialize TOC functionality. */
        public initialize(): void {
            try {
                // Remove previous observers.
                document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((heading) => {
                    this.observer.unobserve(heading);
                });

                // Add new observers.
                headingStore.get().forEach((heading) => {
                    const element = document.getElementById(heading.id);

                    if (element) {
                        this.observer.observe(element);
                    }
                });

                this.renderTOC();

                // Find and activate the first visible heading.
                const entries = headingStore.get();

                if (entries.length > 0) {
                    // Find the first visible heading.
                    const firstVisibleHeading = entries.find((heading) => {
                        const element = document.getElementById(heading.id);

                        if (!element) return false;

                        const rect = element.getBoundingClientRect();

                        return rect.top >= 0 && rect.top <= window.innerHeight * 0.2;
                    });

                    // Update the active heading.
                    this.updateActiveHeading(firstVisibleHeading?.id || entries[0].id);
                }
            } catch (error) {
                logger.error('Failed to initialize TOC', error);
            }
        }
    }

    // Initialize TOC manager.
    try {
        const manager = new TOCManager();
        manager.initialize();

        // Handle Astro page transitions.
        document.addEventListener('astro:page-load', () => {
            manager.initialize();
        });

        // Cleanup on navigation.
        document.addEventListener('astro:before-preparation', () => {
            manager.cleanup();
        });
    } catch (error) {
        logger.error('Failed to initialize TOC manager', error);
    }
</script>

<style is:global>
    #toc-list > li.is-active {
        @apply bg-toc-active-bg shadow-sm dark:bg-toc-active-bg-dark;

        & a {
            @apply text-toc-active-text dark:text-toc-active-text-dark;
        }
    }
</style>
