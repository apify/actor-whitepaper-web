<div class="pointer-events-none fixed right-0 top-0 h-full w-16 mix-blend-exclusion min-[1140px]:pr-4" id="toc-progress">
    <div id="toc-progress-bars" class="relative h-full"></div>
</div>

<nav class="toc-nav" id="toc-nav" aria-label="Table of Contents">
    <div class="sticky left-0 top-0 flex items-center justify-between bg-background-toc-toolbar p-6 dark:bg-background-toc-toolbar-dark">
        <input type="text" id="toc-filter" placeholder="Filter..." aria-label="Filter TOC" class="w-full rounded-md bg-background-toc-filter px-2 py-1 text-toc-item shadow-sm dark:bg-background-toc-filter-dark" />
    </div>

    <ul id="toc-list" class="mb-4 text-toc-item" role="list"></ul>
</nav>

<script>
    import { createLogger } from '../utils/logger';
    import { debounce } from '../utils/debounce';
    import { safeExecute } from '../utils/safe-execute';
    import { TOC } from '../config/components';
    import { headingStore } from '../stores/heading';
    import type { TOCEntry, ProgressBarStyles, HeadingEntry } from '../types/toc';
    import { safeQuerySelector } from '../utils/dom';

    const logger = createLogger({ prefix: 'TOC' });

    interface TOCState {
        isVisible: boolean;
        isScrolling: boolean;
        lastScrollPosition: number;
    }

    interface TOCElements {
        nav: HTMLElement | null;
        filterInput: HTMLElement | null;
        tocList: HTMLElement | null;
        progressBars: HTMLElement | null;
    }

    /** Manager for Table of Contents functionality. */
    class TOCManager {
        private activeId: string = '';

        /** State of the TOC manager. */
        private readonly state: TOCState = {
            isVisible: false,
            isScrolling: false,
            lastScrollPosition: 0
        };

        /** Elements of the TOC. */
        private readonly elements: TOCElements = {
            nav: document.getElementById('toc-nav'),
            filterInput: document.getElementById('toc-filter'),
            tocList: document.getElementById('toc-list'),
            progressBars: document.getElementById('toc-progress-bars')
        };

        /** Intersection observer for tracking heading visibility. */
        private readonly observer: IntersectionObserver;

        /** Interval ID for rendering progress bars. */
        private readonly intervalId: number;

        /** Debounced function to render progress bars. */
        private readonly debouncedRenderProgressBars: () => void;

        constructor() {
            this.observer = new IntersectionObserver((entries) => this.handleIntersection(entries), { rootMargin: TOC.OBSERVER_MARGIN });
            this.debouncedRenderProgressBars = debounce(() => this.renderProgressBars(), TOC.PROGRESS_BAR_DEBOUNCE);
            this.setupEventListeners();
            this.intervalId = window.setInterval(() => this.onScroll(), TOC.SCROLL_CHECK_INTERVAL);
        }

        /**
         * Handles intersection events from the observer.
         *
         * @param entries - Intersection observer entries
         */
        private handleIntersection(entries: IntersectionObserverEntry[]): void {
            if (entries.length) {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        if (entry.target.id) {
                            this.updateActiveHeading(entry.target.id);
                        } else {
                            logger.warn('Intersecting heading element has no ID');
                        }
                    }
                });
            } else {
                logger.warn('Received empty intersection entries');
            }
        }

        /** Sets up event listeners for the TOC. */
        private setupEventListeners(): void {
            headingStore.subscribe((value: readonly HeadingEntry[]) => {
                if (value.length > 0) {
                    logger.info(`${value.length} headings found, rendering TOC`);
                    this.renderTOC();
                } else {
                    logger.warn('No headings found');
                }
            });

            this.elements.filterInput?.addEventListener('input', (event) => {
                const filter = (event.target as HTMLInputElement).value.toLowerCase();
                this.renderTOC(filter);
            });

            window.addEventListener('scroll', () => this.onScroll(), { passive: true });
            window.addEventListener('mousemove', this.handleMouseMove, { passive: true });

            this.elements.tocList?.addEventListener('click', this.handleTOCLinkClick);
        }

        /**
         * Updates the active heading and toggles the active class on the TOC items.
         *
         * @param id - ID of the active heading
         */
        private updateActiveHeading(id: string): void {
            this.activeId = id;

            const tocItems = document.querySelectorAll('.toc-item');

            tocItems.forEach((item) => {
                const link = safeQuerySelector<HTMLAnchorElement>(`a[href="#${id}"]`, item);
                const isActive = link !== null;

                item.classList.toggle('is-active', isActive);

                if (isActive) {
                    this.scrollActiveItemIntoView(item);
                }
            });

            this.renderProgressBars();
            this.updateAriaLabels();
        }

        /**
         * Scrolls the active item into view if it's not already visible.
         *
         * @param item - TOC item element
         */
        private scrollActiveItemIntoView(item: Element): void {
            if (this.elements.nav && this.elements.tocList) {
                try {
                    const tocRect = this.elements.tocList.getBoundingClientRect();
                    const itemRect = item.getBoundingClientRect();
                    const visibleTop = Math.max(tocRect.top, window.innerHeight * TOC.VIEWPORT_MARGINS.TOP + 100);
                    const visibleBottom = Math.min(tocRect.bottom, window.innerHeight * TOC.VIEWPORT_MARGINS.BOTTOM);

                    if (itemRect.top < visibleTop || itemRect.bottom > visibleBottom) {
                        item.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                    }
                } catch (error) {
                    logger.error('Failed to calculate scroll position', error);
                }
            } else {
                logger.error('Required TOC elements not found for scrolling');
            }
        }

        /** Updates the aria labels on the TOC items. */
        private updateAriaLabels(): void {
            const links = document.querySelectorAll('.toc-item a');

            links.forEach((link) => {
                link.setAttribute('aria-current', link.getAttribute('href') === `#${this.activeId}` ? 'true' : 'false');
            });
        }

        /**
         * Gets the styles for the progress bars.
         *
         * @param heading - TOC entry
         * @param index - Index of the heading
         * @returns Progress bar styles
         */
        private getProgressBarStyles(heading: TOCEntry, index: number): ProgressBarStyles {
            return {
                width: (5 - heading.depth) * TOC.PROGRESS_BAR_BASE_WIDTH,
                height: TOC.PROGRESS_BAR_HEIGHT,
                top: index * (TOC.PROGRESS_BAR_HEIGHT + TOC.PROGRESS_BAR_SPACING)
            };
        }

        /** Renders the progress bars. */
        private renderProgressBars(): void {
            safeExecute(
                () => {
                    if (this.elements.progressBars) {
                        const headings = headingStore.get();

                        if (headings.length > 0) {
                            const totalSpacing = (headings.length - 1) * TOC.PROGRESS_BAR_SPACING;
                            const totalBarsHeight = headings.length * TOC.PROGRESS_BAR_HEIGHT;
                            const containerHeight = totalBarsHeight + totalSpacing;

                            this.elements.progressBars.innerHTML = headings
                                .map((heading, index) => {
                                    const styles = this.getProgressBarStyles(heading, index);
                                    return `<div data-heading-id="${heading.id}" class="progress-bar absolute right-0 ${heading.id === this.activeId ? 'bg-toc-progress-active' : 'bg-toc-progress'}" style='width: ${styles.width}px; height: ${styles.height}px; top: ${styles.top}px;'></div>`;
                                })
                                .join('');

                            this.elements.progressBars.style.height = `${containerHeight}px`;
                            this.elements.progressBars.style.top = '50%';
                            this.elements.progressBars.style.transform = 'translateY(-50%)';

                            logger.info(`Rendered ${headings.length} progress bars`);
                        } else {
                            logger.warn('No headings available for progress bars');
                        }
                    } else {
                        logger.error('Progress bars container not found');
                    }
                },
                undefined,
                'Failed to render progress bars'
            );
        }

        /** Handles mouse move events. */
        private handleMouseMove = (event: MouseEvent): void => {
            if (this.elements.nav) {
                const mouseX = event.clientX;
                const windowWidth = window.innerWidth;
                const threshold = windowWidth - TOC.MOUSE_THRESHOLD;
                const shouldShow = mouseX > threshold;

                if (shouldShow !== this.state.isVisible) {
                    this.state.isVisible = shouldShow;
                    this.elements.nav.style.pointerEvents = shouldShow ? 'auto' : 'none';
                    this.elements.nav.style.opacity = shouldShow ? '1' : '0';
                }
            }
        };

        /** ID of the request animation frame. */
        private rafId: number | null = null;

        /** Handles scroll events. */
        private onScroll = (): void => {
            if (this.rafId && this.state.isScrolling) {
                this.state.isScrolling = true;

                this.rafId = requestAnimationFrame(() => {
                    safeExecute(
                        () => {
                            const headings = headingStore.get();
                            const scrollPosition = window.scrollY + window.innerHeight * TOC.VIEWPORT_MARGINS.TOP;
                            const currentPosition = Math.abs(scrollPosition - this.state.lastScrollPosition);

                            if (currentPosition > TOC.SCROLL_THRESHOLD) {
                                this.state.lastScrollPosition = scrollPosition;

                                for (let i = headings.length - 1; i >= 0; i--) {
                                    const element = document.getElementById(headings[i].id);

                                    if (element && element.offsetTop <= scrollPosition) {
                                        this.updateActiveHeading(headings[i].id);
                                        break;
                                    }
                                }
                            }

                            this.debouncedRenderProgressBars();
                            this.updateAriaLabels();

                            this.state.isScrolling = false;
                            this.rafId = null;
                        },
                        undefined,
                        'Failed to handle scroll event'
                    );
                });
            }
        };

        /**
         * Renders the TOC.
         *
         * @param filter - Filter string
         */
        private renderTOC(filter: string = ''): void {
            safeExecute(
                () => {
                    if (this.elements.tocList) {
                        const headings = headingStore.get().filter((heading) => heading.text.toLowerCase().includes(filter));

                        this.elements.tocList.innerHTML = headings.map((heading) => `<li class="toc-item ${heading.id === this.activeId ? 'is-active' : ''}" role="listitem"><a class="toc-depth-${heading.depth - 1}" href="#${heading.id}" aria-current="${heading.id === this.activeId ? 'true' : 'false'}">${heading.text}</a></li>`).join('');

                        this.debouncedRenderProgressBars();
                    }
                },
                undefined,
                'Failed to render TOC'
            );
        }

        /** Cleans up the TOC manager. */
        public cleanup(): void {
            safeExecute(
                () => {
                    if (this.rafId) {
                        cancelAnimationFrame(this.rafId);
                        this.rafId = null;
                    }

                    clearInterval(this.intervalId);

                    window.removeEventListener('scroll', this.onScroll);
                    window.removeEventListener('mousemove', this.handleMouseMove);

                    document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((heading) => {
                        this.observer.unobserve(heading);
                    });

                    this.elements.tocList?.removeEventListener('click', this.handleTOCLinkClick);

                    logger.info('TOC manager cleaned up successfully');
                },
                undefined,
                'Failed to cleanup TOC manager'
            );
        }

        /** Initializes the TOC manager. */
        public initialize(): void {
            safeExecute(
                () => {
                    document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((heading) => {
                        this.observer.unobserve(heading);
                    });

                    headingStore.get().forEach((heading) => {
                        const element = document.getElementById(heading.id);
                        if (element) {
                            this.observer.observe(element);
                        }
                    });

                    this.renderTOC();
                    this.activateFirstVisibleHeading();

                    logger.info('TOC manager initialized successfully');
                },
                undefined,
                'Failed to initialize TOC manager'
            );
        }

        /** Finds and activates the first visible heading. */
        private activateFirstVisibleHeading(): void {
            const entries = headingStore.get();
            let o;

            if (entries.length > 0) {
                const firstVisibleHeading = entries.find((heading) => {
                    const element = document.getElementById(heading.id);

                    if (element) {
                        const rect = element.getBoundingClientRect();

                        o = rect.top >= 0 && rect.top <= window.innerHeight * 0.2;
                    } else {
                        logger.warn(`Heading element not found for ID: ${heading.id}`);
                    }
                });

                if (!firstVisibleHeading) {
                    logger.warn('No visible headings found');
                }

                this.updateActiveHeading(firstVisibleHeading?.id || entries[0].id);
            } else {
                logger.warn('No headings available to activate');
            }

            return o;
        }

        /**
         * Smoothly scrolls to the target element.
         *
         * @param targetId - ID of the target element
         */
        private smoothScrollTo(targetId: string): void {
            const targetElement = document.getElementById(targetId);

            if (targetElement) {
                window.scrollTo({
                    top: targetElement.offsetTop,
                    behavior: 'smooth'
                });
            } else {
                logger.error(`Target heading not found: ${targetId}`);
            }
        }

        /**
         * Handles click events on TOC links.
         *
         * @param event - Click event
         */
        private handleTOCLinkClick = (event: MouseEvent): void => {
            const link = event.target as HTMLAnchorElement;

            if (link.matches('.toc-item a')) {
                event.preventDefault();
                const targetId = link.getAttribute('href')?.substring(1);

                if (targetId) {
                    this.smoothScrollTo(targetId);

                    try {
                        history.pushState(null, '', `#${targetId}`);
                    } catch (error) {
                        logger.error('Failed to update URL hash', error);
                    }
                } else {
                    logger.error('Invalid or missing target ID in TOC link');
                }
            } else {
                logger.warn('Click event on non-TOC link element');
            }
        };
    }

    safeExecute(
        () => {
            const manager = new TOCManager();
            manager.initialize();

            document.addEventListener('astro:page-load', () => {
                manager.initialize();
            });

            document.addEventListener('astro:before-preparation', () => {
                manager.cleanup();
            });
        },
        undefined,
        'Failed to setup TOC manager'
    );
</script>

<style is:global>
    .toc-nav {
        @apply pointer-events-none fixed right-0 top-[10%] h-[80%] w-80 overflow-y-auto rounded-l-xl bg-background-toc opacity-0 shadow-xl min-[1140px]:right-4 min-[1140px]:rounded-xl dark:bg-background-toc-dark;
    }

    .toc-item {
        @apply px-6;

        & a {
            @apply block text-balance px-1 py-1 text-text-toc hover:text-primary-hover dark:text-text-toc-dark dark:hover:text-primary-dark-hover;

            &.toc-depth-1 {
                @apply pl-0;
            }

            &.toc-depth-2 {
                @apply pl-[16px];
            }

            &.toc-depth-3 {
                @apply pl-[32px];
            }

            &.toc-depth-4 {
                @apply pl-[48px];
            }
        }
    }

    .toc-item.is-active {
        @apply bg-background-toc-active shadow-sm dark:bg-background-toc-active-dark;

        & a {
            @apply text-text-toc-active dark:text-text-toc-active-dark;
        }
    }
</style>
