<div class="pointer-events-none fixed right-0 top-0 h-full w-16 min-[1140px]:pr-4" id="toc-progress">
    <div id="toc-progress-bars" class="relative h-full"></div>
</div>

<nav class="pointer-events-none fixed right-0 top-[10%] h-[80%] w-80 overflow-y-auto rounded-l-xl bg-toc-bg opacity-0 shadow-xl transition-opacity duration-200 min-[1140px]:right-4 min-[1140px]:rounded-xl dark:bg-toc-bg-dark" id="toc-nav" aria-label="Table of Contents">
    <div class="bg-toc-toolbar-bg dark:bg-toc-toolbar-bg-dark sticky left-0 top-0 flex items-center justify-between p-6">
        <input type="text" id="toc-filter" placeholder="Filter..." aria-label="Filter TOC" class="bg-toc-filter-bg dark:bg-toc-filter-bg-dark w-full rounded-md px-2 py-1 text-toc-item shadow-sm" />
    </div>

    <ul id="toc-list" class="mb-4 text-toc-item"></ul>
</nav>

<script>
    import { headingStore } from '../stores/heading';

    // State management.
    let activeId = '';

    // DOM element references.
    const nav = document.getElementById('toc-nav');
    const filterInput = document.getElementById('toc-filter');
    const tocList = document.getElementById('toc-list');

    // Subscribe to changes in the headings store.
    // This ensures TOC updates when headings change.
    headingStore.subscribe((headings: string | any[]) => {
        if (headings.length > 0) {
            console.log(`[toc] ${headings.length} headings found, rendering TOC`);
            renderTOC();
        } else {
            console.error('[toc] No headings found');
        }
    });

    // Intersection Observer: Tracks which headings are visible in viewport.
    // rootMargin creates a detection zone in top 20% of viewport.
    const observer = new IntersectionObserver(
        (entries) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    updateActiveHeading(entry.target.id);
                }
            });
        },
        { rootMargin: '0px 0px -80% 0px' }
    );

    // Initialize TOC and progress bars.
    function initialize() {
        // Setup TOC and observers. Remove previous observers if any, and add new ones.
        document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((heading) => {
            observer.unobserve(heading);
        });

        headingStore.get().forEach((heading) => {
            const element = document.getElementById(heading.id);
            if (element) {
                observer.observe(element);
            }
        });

        initializeMouseTracking();
        renderTOC();

        // Find the first visible heading and activate it.
        const entries = headingStore.get();
        if (entries.length > 0) {
            const firstVisibleHeading = entries.find((heading) => {
                const element = document.getElementById(heading.id);
                let o = false;

                if (element) {
                    const rect = element.getBoundingClientRect();
                    o = rect.top >= 0 && rect.top <= window.innerHeight * 0.2;
                }

                return o;
            });

            updateActiveHeading(firstVisibleHeading?.id || entries[0].id);
        }
    }

    // Setup on initial load.
    initialize();

    // Setup after Astro page transitions.
    document.addEventListener('astro:page-load', initialize);

    // Filter TOC entries based on search input.
    filterInput?.addEventListener('input', (event) => {
        const filter = (event.target as HTMLInputElement).value.toLowerCase();
        renderTOC(filter);
    });

    // Update visual state of TOC when active heading changes.
    function updateActiveHeading(id: string) {
        activeId = id;

        document.querySelectorAll('.toc-item').forEach((item) => {
            const isActive = item.querySelector(`a[href="#${id}"]`) !== null;

            item.classList.toggle('is-active', isActive);

            // If this item became active, ensure it's visible in the TOC.
            if (isActive && nav && tocList) {
                const tocRect = tocList.getBoundingClientRect();
                const itemRect = item.getBoundingClientRect();
                const visibleTop = Math.max(tocRect.top, window.innerHeight * 0.1 + 100); // +100 to account for the toolbar height
                const visibleBottom = Math.min(tocRect.bottom, window.innerHeight * 0.9);
                const isAbove = itemRect.top < visibleTop;
                const isBelow = itemRect.bottom > visibleBottom;

                if (isAbove || isBelow) {
                    item.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }
            }
        });

        // Update progress bars.
        document.querySelectorAll('.progress-bar').forEach((bar) => {
            const barId = bar.getAttribute('data-heading-id');

            bar.classList.toggle('bg-toc-progress-active', barId === id);
            bar.classList.toggle('bg-toc-progress', barId !== id);
        });
    }

    // Render TOC list with optional filtering.
    function renderTOC(filter = '') {
        if (tocList) {
            tocList.innerHTML = headingStore
                .get()
                .filter((heading: { text: string }) => heading.text.toLowerCase().includes(filter))
                .map(
                    (heading: { depth: any; id: string; text: any }) => `
                        <li class="toc-item  ${heading.id === activeId ? 'is-active' : ''}">
                            <a class="py-toc-y px-toc-item-x pl-toc-d${heading.depth - 1} block text-balance text-toc-text dark:text-toc-text-dark" href="#${heading.id}">
                                ${heading.text}
                            </a>
                        </li>`
                )
                .join('');
        }

        // Always render progress bars after TOC updates.
        requestAnimationFrame(renderProgressBars);
    }

    // Render progress bars alongside TOC.
    function renderProgressBars() {
        const progressContainer = document.getElementById('toc-progress-bars');

        if (progressContainer) {
            const headings = headingStore.get();
            const spacing = 4;
            const barHeight = 2;
            const totalSpacing = (headings.length - 1) * spacing;
            const totalBarsHeight = headings.length * barHeight;
            const containerHeight = totalBarsHeight + totalSpacing;

            progressContainer.innerHTML = headings
                .map(
                    (heading: { depth: number; id: string }, index: number) => `
                        <div
                            data-heading-id="${heading.id}"
                            class="progress-bar absolute right-0 ${heading.id === activeId ? 'bg-toc-progress-active dark:bg-toc-progress-active-dark' : 'bg-toc-progress dark:bg-toc-progress-dark'}"
                            style="
                                width: ${(5 - heading.depth) * 8}px;
                                height: ${barHeight}px;
                                top: ${index * (barHeight + spacing)}px;
                            "
                        ></div>
                    `
                )
                .join('');

            progressContainer.style.height = `${containerHeight}px`;
            progressContainer.style.top = '50%';
            progressContainer.style.transform = 'translateY(-50%)';
        }
    }

    // Efficient scroll handling with RAF.
    let rafId: number | null = null;

    function onScroll() {
        if (rafId) {
            cancelAnimationFrame(rafId); // cancel previous frame if it hasn't executed yet
        }

        rafId = requestAnimationFrame(() => {
            const entries = headingStore.get();
            const visibleHeading = entries.find((heading) => {
                const element = document.getElementById(heading.id);
                let o = false;

                if (element) {
                    const rect = element.getBoundingClientRect();
                    o = rect.top >= -50 && rect.top <= window.innerHeight * 0.3;
                }

                return o;
            });

            // Fallback to first/last heading when at page boundaries
            if (visibleHeading) {
                if (visibleHeading.id !== activeId) {
                    updateActiveHeading(visibleHeading.id);
                }
            } else {
                const scrollPosition = window.scrollY;
                const isAtTop = scrollPosition < 100;
                const isAtBottom = scrollPosition + window.innerHeight >= document.documentElement.scrollHeight - 100;

                if (isAtTop && entries.length > 0) {
                    updateActiveHeading(entries[0].id);
                } else if (isAtBottom && entries.length > 0) {
                    updateActiveHeading(entries[entries.length - 1].id);
                }
            }

            renderProgressBars();

            rafId = null;
        });
    }

    // Handle keyboard navigation with more reliable updates.
    const keyHandler = (e: KeyboardEvent) => {
        if (['Home', 'End', 'PageUp', 'PageDown', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
            // Multiple checks to ensure we catch the update.
            setTimeout(onScroll, 10);
            setTimeout(onScroll, 100);
            setTimeout(onScroll, 200);
        }
    };

    // Use passive scroll listener.
    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('keyup', keyHandler);

    // Also check periodically for any missed updates.
    const intervalId = setInterval(onScroll, 1000);

    // Cleanup on page navigation.
    document.addEventListener('astro:before-preparation', () => {
        if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = null;
        }

        clearInterval(intervalId);

        window.removeEventListener('scroll', onScroll);
        window.removeEventListener('keyup', keyHandler);
    });

    // Add mouse position tracking.
    function handleMouseMove(e: MouseEvent) {
        const tocNav = document.getElementById('toc-nav');
        if (tocNav) {
            const mouseX = e.clientX;
            const viewWidth = window.innerWidth;
            const tocWidth = tocNav.offsetWidth;
            const showThreshold = 100;
            const hideThreshold = tocWidth + 32;

            if (mouseX >= viewWidth - showThreshold) {
                // Show TOC.
                tocNav.classList.remove('opacity-0', 'pointer-events-none');
                tocNav.classList.add('opacity-100', 'pointer-events-auto');
            } else if (mouseX < viewWidth - hideThreshold) {
                // Hide TOC.
                tocNav.classList.remove('opacity-100', 'pointer-events-auto');
                tocNav.classList.add('opacity-0', 'pointer-events-none');
            }
        }
    }

    // Initialize mouse tracking.
    function initializeMouseTracking() {
        window.addEventListener('mousemove', handleMouseMove, { passive: true });
    }

    // Update cleanup
    document.addEventListener('astro:before-preparation', () => {
        if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = null;
        }
        clearInterval(intervalId);
        window.removeEventListener('scroll', onScroll);
        window.removeEventListener('keyup', keyHandler);
        window.removeEventListener('mousemove', handleMouseMove);
    });
</script>

<style is:global>
    #toc-list > li.is-active {
        @apply bg-toc-active-bg shadow-sm dark:bg-toc-active-bg-dark;

        & a {
            @apply text-toc-active-text dark:text-toc-active-text-dark;
        }
    }
</style>
